# PKI-Public-Key-Infrastructure
## Introduction to PKI (Public Key Infrastructure)

Public Key Infrastructure, as its name indicates, is more like a framework rather than a protocol.

PKI or public key infrastructure is about how two entities learn to trust each other in order to exchange messages securely. You may already know that Kerberos and the KDC (Key Distribution Center) work on a shared-secrets principle, where users can go to a central authority and get authorization to communicate and act in a given network. PKI is a more complex system that understands lots of different networks which may or may not share a common trust authority. In PKI, you’re negotiating trust with a root which then tells you all the other entities that you can trust by default. The central idea of public key infrastructure is that some keys you already trust can delegate their trust (and hence yours) to other keys you don’t yet know. Think of it as a very warm introduction by a friend to someone you don’t yet know!

- the primary components and procedures in the PKI.

   - Asymmetric encryption
   - One-way function
   - Digital signature
   - Digital certificate
   - Certificate Authority

[Wikipedia Link] (https://en.wikipedia.org/wiki/Public_key_infrastructure)

![image](https://user-images.githubusercontent.com/61211023/124836354-c17b0080-df7a-11eb-9129-477405d9ae9f.png)

A public key infrastructure (PKI) is a set of roles, policies, and procedures needed to create, manage, distribute, use, store, and revoke digital certificates and manage public-key encryption.

**Asymmetric encryption**

- A pair of keys
In asymmetric encryption, there is a pair of keys for one identity.
   - Private key
   - Public key
The private key must not be shared to others, while the public key can be shared with anyone.

If you have ever generated keys for application of SSH, you can find them in the following locations.
- ssh-keygen is a tool for creating new authentication key pairs for SSH

- www.ssh.com

   - ~/.ssh/id_rsa // private key
   - ~/.ssh/id_rsa.pub // public key

The file name may be id_rsa or id_dsa, which depending on your key generation algorithm.

**Encryption and decryption**

When a message is encrypted by the private key, it can be decrypted by the paired public key.
On the other hand, the message encrypted by the public key, can be decrypted by the paired private key.

![image](https://user-images.githubusercontent.com/61211023/124837871-9c3bc180-df7d-11eb-87ac-48015fcc781a.png)

**Hash function**

Hash function is a one-way function that its result can be considered a small-sized snapshot of the original message. 
- The calculated result is called digest. 
- It is fast to calculate, and hard to revert. Therefore it is called one-way function.
- The digest for different messages is completely different. 
- Theoretically, there are collisions, but it’s nearly impossible to find the collided message for modern hash function. 

Thus, we can assume that the result of hash function is always unique to each message.

![image](https://user-images.githubusercontent.com/61211023/124838153-2b48d980-df7e-11eb-9eea-1b6123dfded7.png)

**Digital signature**

Digital signature is like a real-life signature. It is used to ensure that the message is confirm by the signer, and no further changes are made beyond the knowledge of the signer.
- The signature is generated by two steps.
   - Get the digest of the message
   - Use sender’s private key to encrypt the digest
    
That is, the encrypted message digest is the sender’s digital signature.

You can see the following diagram learning the steps to verify the integrity of the message by digital signature.

![image](https://user-images.githubusercontent.com/61211023/124838312-78c54680-df7e-11eb-81aa-d39b0e6e9faf.png)

**Digital certificate**

Digital certificate is used to verify the identity of the sender, i.e. authenticity of the sender. 

- Digital certificate contains several main components.
   - Subject (owner)
   - Subject’s public key
   
Issuer’s digital signature, to ensure the identity of subject’s identity and its public key. 

We often call it **Certificate Authority (CA).**

**When we verify a message’s signature, we have to use its public key.**

*How can we ensure that the public key (and the authority’s signature) is really from a trustable authority?*

**Simple solution**

A few certificated authorities are pre-configured in users’ OS and browsers. By the time they install the software, a list of CAs is trusted by default.

You trust several CAs, and the CAs will help you to verify all other people in the world.

**Elements of security**
- The three elements of security are

   1. Authenticity — The message is truely sent from the people we are expecting.
   2. Integrity — The message is not altered by unauthorized people.
   3. Confidentiality — The message is encrypted and can only be decrypted by authorized people.

The two major uses for PKI are for email and web traffic. On a very high level, remember that traffic over the Internet is just a series of packets — little chunks of bits and bytes. While we think of email messages and web requests as philosophically distinct, at the heart, they’re just packets with different port addresses. We define the difference between messages and web requests arbitrarily, but the bits and bytes are transmitted in an identical fashion. So, encrypting those packets is conceptually the same in PKI as well.

The other major use for PKI is a web server authenticating and encrypting communications back and forth between a client — an SSL/TLS certificate that’s installed and working when you see “https” instead of “http” at the beginning of a URL. Most of the time, when we’re talking about PKI in a policy sense or in industry, this is what we mean. Certificate authorities such as DigiCert, Comodo, LetsEncrypt, and others will create those paired keys for websites to use to both verify that they are who they say they are, and to encrypt traffic between a client who’s then been assured that they’re talking to the correct web server and not a visually similar fake site created by an attacker.

There are a few other uses for PKI, including encrypting documents in XML and some Internet Of Things applications (but far, far fewer IoT products are using PKI well than should be, if I can mount my saponified standing cube for a brief moment).

**Why do we use PKI and why do information security experts continue to push people and businesses to use encryption everywhere?**

It’s because encryption is the key (pun absolutely intended) to increasing the expense in terms of time for people who have no business watching your traffic to watch your traffic. Simple tools like Wireshark can sniff and read your mail and web traffic in open wireless access points without it.

**Here’s how to conceptualize PKI**

PKI has become an appliance with service providers and a functional oligopoly of certificate authorities that play well with the major browsers. That isn’t necessarily a bad thing; it’s simply how this technology evolved into its current form of staid usefulness and occasional security hiccups. In reality, most people would do better knowing how best to implement PKI, since vulnerabilities are in general about the endpoints of encryption, not in the encryption itself. For instance: don’t leave 777 perms on the directory with your private keys. If your security is compromised, it’s likely not because someone cracked your key encryption — they just snagged the files from a directory they shouldn’t have been allowed in. Most PKI security issues are actually sysadmin issues. A new 384-bit ECDSA key isn’t going to be cracked by the NSA brute forcing it. It’ll be stolen from a thumb drive at a coffee shop. PKI security is the same as all other kinds of security; if you don’t track your assets and keep them updated, you’ve got Schroedinger’s Vulnerability on your hands.

![image](https://user-images.githubusercontent.com/61211023/124841075-51717800-df84-11eb-8f7e-ee8c9a2a4829.png)

![image](https://user-images.githubusercontent.com/61211023/124841100-63ebb180-df84-11eb-85e4-8068abc6619b.png)

![image](https://user-images.githubusercontent.com/61211023/124841337-e4aaad80-df84-11eb-9b79-9ad39c5d310d.png)


**RSA public key : Behind the scene**

![image](https://user-images.githubusercontent.com/61211023/125069082-2f741480-e0ae-11eb-9497-3f690b20cae9.png)

**What is public and private key in RSA Signing?**
   - Private key is used to sign a mail / file by the sender and public key is used to verify the signature of the mail / file by the recipient.
   - Private key contains the prime numbers, modulus, public exponent, private exponent and coefficients.
   - Public key contains modulus and public exponent.
   - Modulus (n) is the product of two prime numbers used to generate the key pair.
   - Public exponent (d) is the exponent used on signed / encoded data to decode the original value.

**Generate RSA private and public key using openssl**

```shell script
# Generate 1024 bit Private key
$ openssl genrsa -out myprivate.pem 1024
# Separate the public part from the Private key file.
$ openssl rsa -in myprivate.pem -pubout > mypublic.pem
# Display the contents of private key
$ cat myprivate.pem
-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQDRFNU++93aEvz3cV8LSUP9ib3iUxT7SufdVXcgVFK9M3BYzvro
A1uO/parFOJABTkNhTPPP/6mjrU2CPEZJ1zIkpaSNJrrhpp/rNMO9nyLYPGs9Mfd
BiWUPmHW5mY1oD0ye4my0tEsHOlgHC8AhA8OtiHr6IY0agXmH/y5YmSWbwIDAQAB
AoGAAj/IH3pUI6FqqTrF+/gYzCRsL4AXTLC8l8vwkR93GGPyRHJNjqtik8I3WrXJ
zUiBGZ0iNouIsL/+QQuNlGiw/c5i2X3nTntREDS9xs2M0x+MWD/5qI1sn0Qk0HNP
BbDczlvO8wXNFGIHiTiPVEawoeNwhMqJDyGcbsEOZp2pLokCQQDvlMBU6dOeOP9a
jnENFSlrvzNR0nugFeoGmfq6s4Czz2QtUd9baKqBfEBSdJskwFVHgxbFA1Dc7iFu
rJkoQEeFAkEA32j9ibSVryxLvWUZngKNwo2xE+wcYDAYVBMsYC3OBU3FXhVkFD06
ZVnJsY/4bd2VdQI+bI2KV99aHutMJG2WYwJABMn2ZjweTMVa5VZ/kAFiSJMT1Yjd
i7+kY+lkB6Na6T02BWnjixI2hkwThRJrn3pwufM2201Lqn7gEDRHA3T1eQJBAKZG
1RUNo6558HEo8vUIf4vCu33RaJkqkqDYmFmJHeISrQfGMfNiUrkmJ5iRR9w1ZExu
/Bj9C281XDTQ+Z3PNnMCQQCan+pvj0OZH6o0PAMJGBBwRECPpfZ6mUjwA2YD3g61
MHjtIYmKKGmn64Qs8zQ4mNEDboQqyaov3Ij/I6c0ZQlc
-----END RSA PRIVATE KEY-----
```

**Privacy Enhanced Mail (PEM)**
   - Privacy Enhanced Mail (PEM) is a Base64 encoded Distinguished Encoding Rules(DER)
   - PEM file is human readable as it uses 64 printable characters for encoding.
   - It is easy to share PEM file.

**Display the contents of public key PEM file**

```shell scripting
# Display the contents of public key PEM file
$ cat mypublic.pem
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDRFNU++93aEvz3cV8LSUP9ib3i
UxT7SufdVXcgVFK9M3BYzvroA1uO/parFOJABTkNhTPPP/6mjrU2CPEZJ1zIkpaS
NJrrhpp/rNMO9nyLYPGs9MfdBiWUPmHW5mY1oD0ye4my0tEsHOlgHC8AhA8OtiHr
6IY0agXmH/y5YmSWbwIDAQAB
-----END PUBLIC KEY-----
```
**Distinguished Encoding Rules (DER) format of public key**

   - DER is encoded in Type-Length-Value (TLV) format.
   - DER is in binary format for PEM file and follows certain structure for public key.
  
 ```shell scripting
 # Convert PEM file to DER format using openssl rsa
$ openssl rsa -pubin -inform PEM -in mypublic.pem -outform DER -out mypublic.der
# Dump the DER file in hex format.
$ xxd -g 1 -u mypublic.der | cut -c -57
00000000: 30 81 9F 30 0D 06 09 2A 86 48 86 F7 0D 01 01 01
00000010: 05 00 03 81 8D 00 30 81 89 02 81 81 00 D1 14 D5
00000020: 3E FB DD DA 12 FC F7 71 5F 0B 49 43 FD 89 BD E2
00000030: 53 14 FB 4A E7 DD 55 77 20 54 52 BD 33 70 58 CE
00000040: FA E8 03 5B 8E FE 96 AB 14 E2 40 05 39 0D 85 33
00000050: CF 3F FE A6 8E B5 36 08 F1 19 27 5C C8 92 96 92
00000060: 34 9A EB 86 9A 7F AC D3 0E F6 7C 8B 60 F1 AC F4
00000070: C7 DD 06 25 94 3E 61 D6 E6 66 35 A0 3D 32 7B 89
00000080: B2 D2 D1 2C 1C E9 60 1C 2F 00 84 0F 0E B6 21 EB
00000090: E8 86 34 6A 05 E6 1F FC B9 62 64 96 6F 02 03 01
000000a0: 00 01
```
**Structured DER file content**
```shell scripting
1:30 81 9F          // Type: 30 (SEQUENCE)          Length: 0x9F
 2:|  30 0D          // Type: 30 (SEQUENCE)          Length: 0x0D
 3:|  |  06 09       // Type: 06 (OBJECT_IDENTIFIER) Length: 0x09
 4:|  |  -  2A 86 48 // 9 bytes OID value. HEX encoding of
 5:|  |  -  86 F7 0D //     1.2.840.113549.1.1.1
 6:|  |  -  01 01 01 
 7:|  |  05 00       // Type: 05 (NULL)              Length: 0x00
 8:|  03 81 8D       // Type: 03 (BIT STRING)        Length: 0x8D
 9:|  |  -  00       // Number of unused bits in last content byte
10:|  |  30 81 89    // Type: 30 (SEQUENCE)          Length: 0x89
11:|  |  |  02 81 81 // Type: 02 (INTEGER)           Length: 0x81
12:|  |  |  -  00    // Leading ZERO of integer
13:|  |  |  -  D1 14 D5 3E FB DD DA 12 FC F7 71 5F 0B 49 43 FD
14:|  |  |  -  89 BD E2 53 14 FB 4A E7 DD 55 77 20 54 52 BD 33
15:|  |  |  -  70 58 CE FA E8 03 5B 8E FE 96 AB 14 E2 40 05 39
16:|  |  |  -  0D 85 33 CF 3F FE A6 8E B5 36 08 F1 19 27 5C C8
17:|  |  |  -  92 96 92 34 9A EB 86 9A 7F AC D3 0E F6 7C 8B 60
18:|  |  |  -  F1 AC F4 C7 DD 06 25 94 3E 61 D6 E6 66 35 A0 3D
19:|  |  |  -  32 7B 89 B2 D2 D1 2C 1C E9 60 1C 2F 00 84 0F 0E
20:|  |  |  -  B6 21 EB E8 86 34 6A 05 E6 1F FC B9 62 64 96 6F
21:|  |  |  02 03          // Type: 02 (INTEGER)     Length: 0x3
22:|  |  |  -  01 00 01    // Public Exponent. Hex for 65537
```
**DER file contains Object Identifier, Modulus and Public exponent in HEX format.**
   - Lines 4, 5, 6 is the HEX encoding of OID.
   - Lines 13 to 20 is the modulus (n).
   - Line 22 is the public exponent.

**Modulus and Public exponent from public key using openssl**
```shell scripting
# Get Modulus and Public exponent from public PEM file
$ openssl rsa -pubin -inform PEM -text -noout < mypublic.pem
Public-Key: (1024 bit)
Modulus:
    00:d1:14:d5:3e:fb:dd:da:12:fc:f7:71:5f:0b:49:
    43:fd:89:bd:e2:53:14:fb:4a:e7:dd:55:77:20:54:
    52:bd:33:70:58:ce:fa:e8:03:5b:8e:fe:96:ab:14:
    e2:40:05:39:0d:85:33:cf:3f:fe:a6:8e:b5:36:08:
    f1:19:27:5c:c8:92:96:92:34:9a:eb:86:9a:7f:ac:
    d3:0e:f6:7c:8b:60:f1:ac:f4:c7:dd:06:25:94:3e:
    61:d6:e6:66:35:a0:3d:32:7b:89:b2:d2:d1:2c:1c:
    e9:60:1c:2f:00:84:0f:0e:b6:21:eb:e8:86:34:6a:
    05:e6:1f:fc:b9:62:64:96:6f
Exponent: 65537 (0x10001)
```
**Exponent and modulus printed by openssl rsa matches with the Public exponent and modulus from DER file content.**
*OBJECT IDENTIFIER*
OID describes the object. It is a series of nodes separated by period.
**OID Value:** 1.2.840.113549.1.1.1
**OID description:** Identifier for RSA encryption for use with Public Key Cryptosystem One defined by RSA Inc.
**OID Encoding:**
   - The first two nodes of the OID are encoded onto a single byte. The first node is multiplied by the decimal 40 and the result is added to the value of the second node.
   - Node values less than or equal to 127 are encoded on one byte.
   - Node values greater than or equal to 128 are encoded on multiple bytes. Bit 7 of all bytes except the rightmost byte is set to one. Bits 0 through 6 of each byte          contains the encoded value.















